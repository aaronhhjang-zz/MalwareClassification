import os
import pickle
import re
import pandas as pd
import logging


signature_csv_file_name = "signature_descriptions_all.csv"
model_file_name = "model.pkl"
index_map = [0, 8, 15, 17, 21, 30, 31, 33, 40, 86, 126, 128, 174, 185, 236, 240, 442]

def main():
    logging.basicConfig(filename="cli-debug.log",
                            filemode='a',
                            format='%(asctime)s %(levelname)s %(message)s',
                            datefmt="%Y-%m-%d %H:%M:%S",
                            level=logging.DEBUG)

    exit = False
    while(not exit):

        print("Malware Classification ... \n")
    
        is_score_valid = False
        while(not is_score_valid):
            user_input_score = input("Please input the estimate score between 0 and 10: ")

            # If user pressed x to quit
            user_input_score = user_input_score.strip()
            if user_input_score == ('x'):
                is_features_valid = True
                exit = True
                break      
            
            user_input_score, is_score_valid = input_validation_score(user_input_score)

        if exit: 
            break
        
        signatures = get_used_signatures()

        i = 0
        for signature in signatures:
            print(str(i) + " : " + signature)
            i += 1
        print("x: Terminate")
        
        print("\n")

        is_features_valid = False
        while(not is_features_valid):
            user_input_features = input("Select the malware signatures from the list above separated by ',' (Ex: 1,2,5): ")

            # If user pressed x to quit
            user_input_features = user_input_features.strip()
            if user_input_features == ('x'):
                is_features_valid = True
                exit = True
                break

            # very basic input check, should be improved
            is_features_valid = input_validation_features(user_input_features) 

        if exit:
            break

        # Take the input and convert to array
        selected_indexes = user_input_features.split(',') 

        df_indexes = indexes_to_df_indexes(selected_indexes)

        inputs_df = df_constructor(df_indexes, user_input_score)
        runModel(inputs_df)



    print("Exiting malware classification ...")

def constains_num_comma(strg, search=re.compile(r'[^0-9,]').search):
    return not bool(search(strg))

def input_validation_score(score):
    is_valid = False
    try:
        score = float(score)
        if(score >= 0 and score <= 10):
            is_valid = True
        else:
            print("Score has to be between 0-10. Try again!")
    except:
        print("Invalid score input. Try again!")
    finally:
        return score, is_valid

def input_validation_features(features):
    is_valid = False
    try:
        if not constains_num_comma(features):
            raise Exception("Can only contain numbers and ,")
        else:
            is_valid = True
    except:
        print("Invalid input. Try again!")
    finally:
        return is_valid

def indexes_to_df_indexes(indexes):
    df_indexes = []
    
    for index in indexes:
        df_indexes.append(index_map[int(index)])
        
    return df_indexes

    # get from signatures_descriptions_onlyUsed.csv all signatures into an array
    # return that array
def get_used_signatures():
    # temp return statement
    return ['Allocates read-write-execute memory (usually to unpack itself)',
     'Checks if process is being debugged by a debugger',
     'Checks whether any human activity is being performed by constantly checking whether the foreground window changed',
     'Looks for the Windows Idle Time to determine the uptime', 'A process attempted to delay the analysis task.',
     'Queries for the computername',
     'Queries the disk size which could be used to detect virtual machine with small fixed size or dynamic allocation',
     'Checks the CPU name from registry, possibly for anti-virtualization',
     'Checks amount of memory in system, this can be used to detect virtual machines that have a low amount of memory available',
     'Zeus P2P (Banking Trojan)', 'Creates a shortcut to an executable file',
     'Uses Windows APIs to generate a cryptographic key',
     'Creates a windows hook that monitors keyboard input (keylogger)',
     'Tries to locate where the browsers are installed',
     'Checks for the Locally Unique Identifier on the system for a suspicious privilege',
     'One or more processes crashed', 'Communicates with host for which no DNS query was performed']

 # TODO: Write a function that takes df_indexes and constructs the 'inputs' datafram that is to be passed into
        # the model. The index in df_indexes should be 1, while the rest are 0
def df_constructor(indexes, score):
    columns = get_all_features()
    # print(len(columns)) #448 TODO REMOVE
    columns.insert(0, "score")
    # print(len(columns)) #449 TODO REMOVE

    # print('=====DEBUG=====') # TODO REMOVE
    # print(columns) # TODO REMOVE

    #first, create entire list
    df = pd.DataFrame(index=[0], columns=columns) 
    df = df.fillna(0)  # with 0s rather than NaNs
    df.iat[0, 0] = score
    #replace 0 with 1
    for i in indexes:
        df.iat[0, i + 1] = 1
    # with pd.option_context('display.max_rows', None, 'display.max_columns', None):  # more options can be specified also
    #     print(df)
    return df


def get_all_features():
    file_read = open(signature_csv_file_name, "r")
    content = file_read.read()
    features = content.split(";")
    file_read.close()
    return features


#take the users input and run the model on it, return the malware family prediction
def runModel(input):
    if os.path.exists(model_file_name):
        print("Loading ML model . . .")
        model = pickle.load(open(model_file_name, "rb"))
        prediction = model.predict(input)
        print(prediction)
        return prediction

if __name__ == "__main__":
    main()
